/*
 * Infomaniak kDrive - Desktop
 * Copyright (C) 2023-2025 Infomaniak Network SA
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#ifdef __GNUC__
// /!\ moc issue => filesystem must be included after QApplication
// https://bugreports.qt.io/browse/QTBUG-73263
#include <QApplication>
#endif

#include "cstypes.h"
#include "sourcelocation.h"

#include <filesystem>
#include <functional>
#include <cctype>
#include <optional>
#include <sstream>
#include <string>
#include <unordered_set>
#include <variant>
#include <signal.h>

#include <QDebug>

namespace KDC {

//
// Aliases
//
using SyncTime = int64_t;
using DbNodeId = int64_t;
using UniqueId = int64_t;
using SyncDbRevision = uint64_t;
using SnapshotRevision = uint64_t;
using NodeId = std::string;
using SyncPath = std::filesystem::path;
using SyncName = std::filesystem::path::string_type;
using SyncChar = std::filesystem::path::value_type;
using DirectoryEntry = std::filesystem::directory_entry;
using DirectoryOptions = std::filesystem::directory_options;
using DoubleSeconds = std::chrono::duration<double>; // Use double instead of std::chrono::seconds to keep the precision

using SigValueType = std::variant<bool, int, int64_t, uint64_t, double, std::string, std::wstring>;

#if defined(KD_WINDOWS)
using StringStream = std::wstringstream;
using OStringStream = std::wostringstream;
#define Str(s) L##s
#define SyncName2QStr(s) QString::fromStdWString(s)
#define QStr2SyncName(s) s.toStdWString()
#define Str2SyncName(s) KDC::CommonUtility::s2ws(s)
#define SyncName2Str(s) KDC::CommonUtility::ws2s(s)
#define WStr2SyncName(s) SyncName(s)
#define SyncName2WStr(s) s
#else
using StringStream = std::stringstream;
using OStringStream = std::ostringstream;
#define Str(s) s
#define SyncName2QStr(s) QString::fromStdString(s)
#define QStr2SyncName(s) s.toStdString()
#define Str2SyncName(s) SyncName(s)
#define SyncName2Str(s) s
#define WStr2SyncName(s) KDC::CommonUtility::ws2s(s)
#define SyncName2WStr(s) KDC::CommonUtility::s2ws(s)
#endif

#define XMLStr2Str(s) Poco::XML::fromXMLString(s)

#define QStr2Str(s) s.toStdString()
#define QStr2WStr(s) s.toStdWString()

#define QStr2Path(s) std::filesystem::path(QStr2SyncName(s))
#define Path2QStr(p) SyncName2QStr(p.native())

// Bug in gcc => std::filesystem::path wstring is crashing with non ASCII characters
// Fixed in next gcc-12 version
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95048
#ifdef __GNUC__
#define Path2WStr(p) KDC::CommonUtility::s2ws(p.native())
#define Path2Str(p) p.native()
#define Str2Path(s) std::filesystem::path(s)
#else
#define Path2WStr(p) p.native()
#define Path2Str(p) CommonUtility::ws2s(p.native())
#define Str2Path(s) std::filesystem::path(CommonUtility::s2ws(s))
#endif

// Types used by the Communication layer
using CommString = std::filesystem::path::string_type;
using CommChar = std::filesystem::path::value_type;
using CommBLOB = std::vector<char>;

using ExecuteCommand = std::function<void(const CommString &command, bool broadcast)>;

//
// Constants
//
static constexpr int64_t selfRestarterDisableValue = -1;
static constexpr int64_t selfRestarterNoCrashDetected = 0;

namespace event_dump_files {
static constexpr std::string_view serverCrashFileName(
        "kdrive.crash"); // Name of the file generated by the crash handler when a crash of the server occurs
static constexpr std::string_view serverKillFileName(
        "kdrive.kill"); // Name of the file generated by the crash handler when a kill of the server occurs
static constexpr std::string_view clientCrashFileName(
        "kdrive_client.crash"); // Name of the file generated by the crash handler when a crash of the client occurs
static constexpr std::string_view clientKillFileName(
        "kdrive_client.kill"); // Name of the file generated by the crash handler when a kill of the client occurs

static constexpr std::string_view serverCrashEventFileName(
        "kdrive.crash.event"); // Name of the debug file generated by Sentry on_crash callback of the server
static constexpr std::string_view serverSendEventFileName(
        "kdrive.send.event"); // Name of the debug file generated by Sentry before_send callback of the server
static constexpr std::string_view clientCrashEventFileName(
        "kdrive_client.crash.event"); // Name of the debug file generated by Sentry on_crash callback of the client
static constexpr std::string_view clientSendEventFileName(
        "kdrive_client.send.event"); // Name of the debug file generated by Sentry before_send callback of the client
static constexpr std::string_view testCrashEventFileName(
        "kdrive_test.crash.event"); // Name of the debug file generated by Sentry on_crash callback of the test
static constexpr std::string_view testSendEventFileName(
        "kdrive_test.send.event"); // Name of the debug file generated by Sentry before_send callback of the test
} // namespace event_dump_files

static const auto messageCdeSeparator = Str(":");
static const auto messageArgSeparator = Str("\x1e");
static const auto responseToFinderArgSeparator = Str(":");

static const std::unordered_set<ConflictType> conflictsWithLocalRename = {ConflictType::CreateCreate, ConflictType::EditEdit};

// Stream Operator (toString)
static const std::string noConversionStr("No conversion to string available");

//
// Hash functions
//
struct StringHashFunction {
        using is_transparent = void; // Enables heterogeneous operations.

        std::size_t operator()(const std::string_view sv) const {
            constexpr std::hash<std::string_view> hasher;
            return hasher(sv);
        }
};

struct PathHashFunction {
        std::size_t operator()(const std::optional<SyncPath> &path) const { return path ? hash_value(path.value()) : 0; }
};

struct SyncNameHashFunction {
        using is_transparent = void; // Enables heterogeneous operations.

        std::size_t operator()(const SyncName &name) const {
            constexpr std::hash<SyncName> hashFunction;
            return hashFunction(name);
        }
};

using NodeSet = std::unordered_set<NodeId, StringHashFunction, std::equal_to<>>;
using SyncNameSet = std::unordered_set<SyncName, SyncNameHashFunction, std::equal_to<>>;
using StrSet = std::unordered_set<std::string, StringHashFunction, std::equal_to<>>;

//
// Enums
// /!\ Each enum class must have a corresponding toString function
//
enum class ActionTarget {
    Drive = 0,
    Sync,
    AllDrives,
    EnumEnd
};

enum class ActionType {
    Stop = 0,
    Start,
    EnumEnd
};

enum class AppStateKey {
    // Adding a new key here requires to add it in insertDefaultAppState in parmsdbappstate.cpp
    LastServerSelfRestartDate,
    LastClientSelfRestartDate,
    LastSuccessfulLogUploadDate, // Format: "month,day,year,hour,minute,second"
    LastLogUploadArchivePath,
    LogUploadState,
    LogUploadPercent,
    LogUploadToken,
    AppUid,
    NoUpdate,
    Unknown, // Only for initialization purpose
    EnumEnd
};

enum class AppType {
    None,
    Server,
    Client,
    Test,
    EnumEnd
};

namespace sentry {
enum class ConfidentialityLevel {
    Anonymous, // The sentry will not be able to identify the user (no ip, no email, no username, ...)
    Authenticated, // The sentry will contain information about the last user connected to the application. (email,
                   // username, user id, ...)
    Specific, // The sentry will contain information about the user passed as a parameter of the call to captureMessage.
    None, // Not initialized
    EnumEnd
};
} // namespace sentry

enum class ExclusionTemplateComplexity {
    Simplest = 0,
    Simple,
    Complex,
    EnumEnd
};

enum class IoError {
    Success = 0,
    AccessDenied,
    AttrNotFound,
    DirectoryExists,
    DiskFull,
    FileExists,
    FileNameTooLong,
    InvalidArgument,
    InvalidDirectoryIterator,
    InvalidFileName,
    IsADirectory,
    IsAFile,
    MaxDepthExceeded,
    NoSuchFileOrDirectory,
    ResultOutOfRange,
    CrossDeviceLink,
    FileOrDirectoryCorrupted,
    Unknown,
    EnumEnd
};

enum class LinkType {
    None = 0,
    Symlink,
    Hardlink,
    FinderAlias,
    Junction,
    EnumEnd
};

enum class LogUploadState {
    None,
    Archiving,
    Uploading,
    Success,
    Failed,
    CancelRequested,
    Canceled,
    EnumEnd
};

enum class NodeStatus {
    Unknown = 0,
    Unprocessed,
    PartiallyProcessed,
    Processed,
    ConflictOpGenerated,
    EnumEnd
};

enum class OperationType {
    None = 0x00,
    Create = 0x01,
    Move = 0x02,
    Edit = 0x04,
    MoveEdit = (Move | Edit),
    Delete = 0x08,
    Rights = 0x10,
    MoveOut = 0x20
};

enum class PinState {
    Inherited, // The pin state is inherited from the parent folder. It can only be set and should never be returned by a getter.
    AlwaysLocal, // The content is always available on the device.
    OnlineOnly, // The content resides only on the server and is downloaded on demand.
    Unspecified, // Indicates that the system is free to (de)hydrate the content as needed.
    Unknown, // Represents an uninitialized state or an error. It has no equivalent in filesystems.
    EnumEnd
};

enum class Platform {
    MacOS,
    Windows,
    WindowsServer,
    LinuxAMD,
    LinuxARM,
    Unknown,
    EnumEnd
};

enum class ReplicaSide {
    Unknown,
    Local,
    Remote,
    EnumEnd
};

enum class SignalCategory {
    Kill,
    Crash,
    EnumEnd
};

enum class SignalType {
    None = 0,
    Int = SIGINT,
    Ill = SIGILL,
    Abrt = SIGABRT,
    Fpe = SIGFPE,
    Segv = SIGSEGV,
    Term = SIGTERM,
#ifndef Q_OS_WIN
    Bus = SIGBUS
#endif
};

enum class SyncNodeType {
    Undefined = 0,
    BlackList, // Nodes that are excluded from sync
    WhiteList, // Explicitly whitelisted nodes (e.g. folder size above limit but user want to sync anyway). Note: all
               // nodes in none of those lists are implicitly whitelisted
    UndecidedList, // Considered as blacklisted until user action
    TmpRemoteBlacklist, // Blacklisted temporarily
    TmpLocalBlacklist, // Blacklisted temporarily
    EnumEnd
};

enum class SyncStatus {
    Undefined,
    Starting,
    Running,
    Idle,
    PauseAsked,
    Paused,
    StopAsked,
    Stopped,
    Error,
    EnumEnd
};

enum class SyncStep {
    None = 0,
    Idle,
    UpdateDetection1, // Compute operations
    UpdateDetection2, // Update Trees
    Reconciliation1, // Platform Inconsistency Checker
    Reconciliation2, // Conflict Finder
    Reconciliation3, // Conflict Resolver
    Reconciliation4, // Operation Generator
    Propagation1, // Sorter
    Propagation2, // Executor
    Done,
    EnumEnd
};

enum class UploadSessionType {
    Unknown,
    Drive,
    Log,
    EnumEnd
};

enum class UpdateState {
    UpToDate,
    Checking,
    Available,
    ManualUpdateAvailable,
    Downloading,
    Ready,
    CheckError,
    DownloadError,
    UpdateError,
    NoUpdate,
    Unknown,
    EnumEnd
};

enum class UnicodeNormalization {
    NFC,
    NFD
};

// Adding a new types here requires to add it in stringToAppStateValue and appStateValueToString in libcommon/utility/utility.cpp
using AppStateValue = std::variant<std::string, int, int64_t, LogUploadState>;

//
// Concepts
//
template<class C> // Any enum class
concept EnumClass = std::is_enum_v<C>;

template<class C> // Any enum class that can be converted to (and from) int
concept IntegralEnum = EnumClass<C> && std::is_convertible_v<std::underlying_type_t<C>, int>;

template<class C> // Any types that can be converted to an int
concept ConvertibleToInt = requires(C e) { static_cast<int>(e); };

template<class C> // Any types that can be converted to string
concept LogableType = requires(C e) { toString(e); };

template<class C> // Any enum class we want to allow bitwise operations (OperationType & InconsistencyType)
concept AllowBitWiseOpEnum = IntegralEnum<C> && (std::is_same_v<C, OperationType> || std::is_same_v<C, InconsistencyType>);

//
// Converters
//
template<ConvertibleToInt C>
inline constexpr int toInt(C e) {
    return static_cast<int>(e);
}

template<IntegralEnum C>
inline constexpr C fromInt(int e) {
    return static_cast<C>(e);
}

//
// Operators
//
template<AllowBitWiseOpEnum C>
inline C operator|=(C &a, const C b) {
    return a = fromInt<C>(toInt(a) | toInt(b));
}

template<AllowBitWiseOpEnum C>
inline C operator&=(C &a, const C b) {
    return a = fromInt<C>(toInt(a) & toInt(b));
}

template<AllowBitWiseOpEnum C>
inline C operator^=(C &a, const C b) {
    return a = fromInt<C>(toInt(a) ^ toInt(b));
}

template<AllowBitWiseOpEnum C>
inline C operator|(const C a, const C b) {
    return fromInt<C>(toInt(a) | toInt(b));
}

template<AllowBitWiseOpEnum C>
inline C operator&(const C a, const C b) {
    return fromInt<C>(toInt(a) & toInt(b));
}

template<AllowBitWiseOpEnum C>
inline C operator^(const C a, const C b) {
    return fromInt<C>(toInt(a) ^ toInt(b));
}

namespace typesUtility {
std::wstring stringToWideString(const std::string &str); // Convert string to wstring (We can't use the s2ws of Utility because
                                                         // it's in libCommonServer and it includes types.h)
} // namespace typesUtility

template<LogableType C>
std::string toStringWithCode(C e) {
    return toString(e) + "(" + std::to_string(toInt(e)) + ")"; // Example: "Ok(1)"
}

template<LogableType C>
inline std::wostream &operator<<(std::wostream &wos, C e) {
    return wos << typesUtility::stringToWideString(toStringWithCode(e));
}

template<LogableType C>
inline std::ostream &operator<<(std::ostream &os, C e) {
    return os << toStringWithCode(e);
}

template<LogableType C>
inline QDebug &operator<<(QDebug &os, C e) {
    return os << toStringWithCode(e).c_str();
}

//
// Functions
//
std::string toString(ActionTarget e);
std::string toString(ActionType e);
std::string toString(AppStateKey e);
std::string toString(AppType e);
std::string toString(CancelType e);
std::string toString(sentry::ConfidentialityLevel e);
std::string toString(ConflictType e);
std::string toString(ErrorLevel e);
std::string toString(ExclusionTemplateComplexity e);
std::string toString(ExitCode e);
std::string toString(ExitCause e);
std::string toString(InconsistencyType e);
std::string toString(IoError e);
std::string toString(Language e);
std::string toString(LinkType e);
std::string toString(LogLevel e);
std::string toString(LogUploadState e);
std::string toString(NodeStatus e);
std::string toString(NodeType e);
std::string toString(NotificationsDisabled e);
std::string toString(OperationType e);
std::string toString(PinState e);
std::string toString(Platform e);
std::string toString(ProxyType e);
std::string toString(ReplicaSide e);
std::string toString(SignalCategory e);
std::string toString(SignalType e);
std::string toString(SyncDirection e);
std::string toString(SyncFileInstruction e);
std::string toString(SyncFileStatus e);
std::string toString(SyncNodeType e);
std::string toString(SyncStatus e);
std::string toString(SyncStep e);
std::string toString(UploadSessionType e);
std::string toString(UpdateState e);
std::string toString(VersionChannel e);
std::string toString(VirtualFileMode e);

inline ReplicaSide otherSide(const ReplicaSide side) {
    if (side == ReplicaSide::Unknown) return ReplicaSide::Unknown;
    return side == ReplicaSide::Local ? ReplicaSide::Remote : ReplicaSide::Local;
}

// All conflict types whose resolution involves adding a "_conflict_" suffix to the local file's name.
inline bool isConflictsWithLocalRename(const ConflictType type) {
    return conflictsWithLocalRename.contains(type);
}

template<AllowBitWiseOpEnum C>
inline bool bitWiseEnumToBool(const C a) {
    return toInt(a) != 0;
}

//
// Structures
//
struct ExitInfo {
        ExitInfo() = default;
        constexpr ExitInfo(const ExitCode &code, const ExitCause &cause,
                           const SourceLocation srcLoc = SourceLocation::currentLoc()) :
            _code(code),
            _cause(cause),
            _srcLoc(srcLoc) {}

        ExitInfo(const ExitCode &code, const SourceLocation srcLoc = SourceLocation::currentLoc()) :
            _code(code),
            _srcLoc(srcLoc) {}

        const ExitCode &code() const { return _code; }
        const ExitCause &cause() const { return _cause; }
        void setCause(const ExitCause cause) { _cause = cause; }
        operator ExitCode() const { return _code; }
        operator ExitCause() const { return _cause; }
        explicit operator std::string() const {
            // Example: "ExitInfo{SystemError-NotFound from (file.cpp:42[functionName])}"
            // Example: "ExitInfo{Ok-Unknown}"
            return "ExitInfo{" + toString(code()) + "-" + toString(cause()) + srcLocStr() + "}";
        }
        constexpr operator bool() const { return _code == ExitCode::Ok || _code == ExitCode::TokenRefreshed; }
        constexpr explicit operator int() const { return toInt(_code) * 100 + toInt(_cause); }
        constexpr bool operator==(const ExitInfo &other) const { return _code == other._code && _cause == other._cause; }
        constexpr bool operator!=(const ExitInfo &other) const { return !(*this == other); }

        //! Merge 'this' object with an exitInfoToMerge given as a parameter, according to an ExitCode list ordered by priority:
        //! - If 'this' object's code has priority over the parameter's code, do nothing.
        //! - Else, update 'this' object using the exitInfoToMerge parameter.
        /*!
          \param exitInfo is used to update 'this' object.
          \param exitCodeList is a vector of ExitCode(s) ranked by decreasing priority.
        */
        void merge(const ExitInfo &exitInfoToMerge, const std::vector<ExitCode> &exitCodeList);
        static ExitInfo fromInt(const int val) {
            return ExitInfo(static_cast<ExitCode>(val / 100), static_cast<ExitCause>(val % 100));
        }

    private:
        ExitCode _code{ExitCode::Unknown};
        ExitCause _cause{ExitCause::Unknown};
        SourceLocation _srcLoc;

        std::string srcLocStr() const {
            if (_code == ExitCode::Ok) return "";
            return " from (" + _srcLoc.toString() + ")";
        }

        static long indexInList(const ExitCode &exitCode, const std::vector<ExitCode> &exitCodeList);

        friend class TestTypes;
};
std::string toString(ExitInfo e);

struct ItemType {
        NodeType nodeType{NodeType::Unknown}; // The type of a link is `NodeType::File`.
        LinkType linkType{LinkType::None};
        NodeType targetType{NodeType::Unknown}; // The type of the target item when `linkType` is not `LinkType::None`.
        SyncPath targetPath;
        // The value of the data member `ioError` is `IoError::NoSuchFileOrDirectory` if
        // - the file or directory indicated by `path` doesn't exist
        // - the file or directory indicated by `path` is a symlink or an alias (in which case `linkType` is different from
        // `LinkType::Unknown`) and its target doesn't exist.
        IoError ioError{IoError::Success};
        bool operator==(const ItemType &other) const {
            return nodeType == other.nodeType && linkType == other.linkType && targetType == other.targetType &&
                   targetPath == other.targetPath && ioError == other.ioError;
        }
};

struct VersionInfo {
        VersionChannel channel = VersionChannel::Unknown;
        std::string tag; // Version number. Example: 3.6.4
        // std::string changeLog; // List of changes in this version, not used for now.
        uint64_t buildVersion{0}; // Example: 20240816
        std::string buildMinOsVersion; // Optional. Minimum supported version of the OS. Examples: 10.15, 11, server 2005, ...
        std::string downloadUrl; // URL to download the version

        bool operator==(const VersionInfo &other) const {
            return channel == other.channel && tag == other.tag && buildVersion == other.buildVersion &&
                   buildMinOsVersion == other.buildMinOsVersion && downloadUrl == other.downloadUrl;
        }

        [[nodiscard]] bool isValid() const {
            return channel != VersionChannel::Unknown && !tag.empty() && buildVersion != 0 && !downloadUrl.empty();
        }

        [[nodiscard]] std::string fullVersion() const {
            std::stringstream ss;
            ss << tag << "." << buildVersion;
            return ss.str();
        }

        [[nodiscard]] std::string beautifulVersion() const {
            std::stringstream ss;
            ss << tag << " (" << buildVersion << ")";
            return ss.str();
        }

        void clear() {
            channel = VersionChannel::Unknown;
            tag.clear();
            buildVersion = 0;
            buildMinOsVersion.clear();
            downloadUrl.clear();
        }

        friend QDataStream &operator>>(QDataStream &in, VersionInfo &versionInfo) {
            QString tmpTag;
            quint64 tmpBuildVersion = 0;
            QString tmpBuildMinOsVersion;
            QString tmpDownloadUrl;
            in >> versionInfo.channel >> tmpTag >> tmpBuildVersion >> tmpBuildMinOsVersion >> tmpDownloadUrl;
            versionInfo.tag = tmpTag.toStdString();
            versionInfo.buildVersion = tmpBuildVersion;
            versionInfo.buildMinOsVersion = tmpBuildMinOsVersion.toStdString();
            versionInfo.downloadUrl = tmpDownloadUrl.toStdString();
            return in;
        }

        friend QDataStream &operator<<(QDataStream &out, const VersionInfo &versionInfo) {
            out << versionInfo.channel << QString::fromStdString(versionInfo.tag)
                << static_cast<quint64>(versionInfo.buildVersion) << QString::fromStdString(versionInfo.buildMinOsVersion)
                << QString::fromStdString(versionInfo.downloadUrl);
            return out;
        }
};

using AllVersionsInfo = std::unordered_map<VersionChannel, VersionInfo>;

struct NodeIds {
        DbNodeId dbNodeId;
        NodeId localNodeId;
        NodeId remoteNodeId;
        NodeId nodeId(const ReplicaSide side) const { return side == ReplicaSide::Local ? localNodeId : remoteNodeId; }
        struct HashFunction {
                std::size_t operator()(const NodeIds &nodeIds) const { return std::hash<DbNodeId>()(nodeIds.dbNodeId); }
        };
        bool operator==(const NodeIds &other) const {
            return dbNodeId == other.dbNodeId && localNodeId == other.localNodeId && remoteNodeId == other.remoteNodeId;
        }
};

} // namespace KDC
